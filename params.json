{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","tagline":"The Haskell tracer - generating and viewing Haskell execution traces","name":"Hat","body":"Hat is a source-level tracer for the programming language [Haskell](http://www.haskell.org). Hat gives access to detailed, otherwise invisible information about a computation.\r\n\r\nHat helps locating errors in programs. Furthermore, it is useful for understanding how a (correct) program works, especially for teaching and program maintenance. Hat is not a time or space profiler. Hat can be used for programs that terminate normally, that terminate with an error message or that terminate when interrupted by the programmer.\r\n\r\n### How do I use it?\r\n\r\nTracing a program with Hat consists of two phases: \r\n\r\nFirst you run your program such that it additionally writes a trace to file. \r\nTo do so you use _hat-trans_ to translate all the source modules _Module_ of your Haskell program into tracing versions _Hat.Module_. You compile these and when run the program does exactly the same as the original program except for additionally writing a trace to file.\r\n\r\nSecond, after the program has terminated, you view the trace with a browsing tool. The trace consists of high-level information about the computation. It describes each reduction, that is, the replacements of an instance of a left-hand side of an equation by an instance of its right-hand side, and the relation of the reduction to other reductions. Because the trace describes the whole computation, it is huge. Hat comes with several tools to selectively view the fragments of the trace that are of interest. Each tool shows fragments of the computation in a particular way, highlighting a specific aspect.\r\n\r\n### How can I view a trace?\r\n\r\n\r\nAll tools show function arguments in evaluated form, more precisely: as\r\nfar evaluated as the arguments are at the end of the computation. For\r\nexample, although in a computation the unevaluated expression <kbd>(map\r\n(+5) [1,2])</kbd> might be passed to the function <kbd>length</kbd>,\r\nthe tools will show the function application as <kbd>length\r\n[1+5,2+5]</kbd> or <kbd>length [_,_]</kbd>.\r\n\r\n<p>\r\nFor example, the computation of the faulty program\r\n<pre>\r\nmain = let xs :: [Int]\r\n           xs = [4*2,5 `div` 0,5+6]\r\n       in  print (head xs,last' xs)\r\n\r\nlast' (x:xs) = last' xs\r\nlast' [x] = x\r\n</pre>\r\n\r\ngives the result\r\n<pre>\r\n(8, No match in pattern.\r\n</pre>\r\nand the Hat viewing tools can be used to explore its behaviour as follows:\r\n\r\n<ul>\r\n\r\n<li><strong>Hat-observe</strong> (inspired by <a\r\nhref=\"http://haskell.org/hood\">Hood</a>) <br>\r\n\r\nHat-observe is an interactive tool that shows how top-level functions\r\nare used.  That is, for a given top-level function name it shows\r\nall the arguments with which it is called during the computation,\r\ntogether with the respective results.\r\n\r\n<pre>\r\n$ hat-observe Example\r\n\r\n                hat-observe 2.04    (:h for help, :q to quit)\r\n\r\nhat-observe&gt; main\r\n<font color=blue>1</font>  main = IO (print (8,_|_))\r\nhat-observe&gt; print\r\n<font color=blue>1</font>  print (8,_|_) = IO (print (8,_|_))\r\nhat-observe&gt; last'\r\n<font color=blue>1</font>  last' [8,_,_] = _|_\r\n<font color=blue>2</font>  last' [_,_] = _|_\r\n<font color=blue>3</font>  last' [_] = _|_\r\n<font color=blue>4</font>  last' [] = _|_\r\nhat-observe&gt; :quit\r\n$\r\n</pre>\r\n<p>\r\n\r\n<li><strong>Hat-trail</strong><br>\r\n\r\nHat-trail is an interactive tool that enables exploring a computation\r\n<em>backwards</em>, starting at the program output or an error message\r\n(with which the computation aborted).  This is particularly useful\r\nfor locating an error.  You start at the observed faulty behaviour\r\nand work backwards towards the source of the error.\r\n\r\n<p>\r\nEvery reduction replaces an instance of the left-hand side of a program\r\nequation by an instance of its right-hand side. The instance of the\r\nleft-hand side ``creates'' the instance of the right-hand side and is\r\ntherefore called its <em>parent</em>. With hat-trail you can obtain\r\nthe parent of any expression.\r\n\r\n<p>\r\n(Note: if you cannot see any highlighting in the following diagram,\r\ntry changing the fixed-width font in your browser to something like\r\nCourier text.)  Each line of the trail is the parent of the highlighted\r\nsubexpression directly above it.\r\n\r\n<pre>\r\n<strong>Error: -------------------------------------------------------</strong>\r\n<font color=red>No match in pattern.</font>\r\n<strong>Output: ------------------------------------------------------</strong>\r\n(8,\r\n<strong>Trail: ---------------------- </strong>Example.hs line: 2 col: 12<strong> -----</strong>\r\n&lt;- <font color=red>last' []</font>\r\n&lt;- <font color=red>last' [_]</font>\r\n&lt;- <font color=red>last' [_,_]</font>\r\n&lt;- last' [<font color=red>8</font>,_,_]\r\n&lt;- <font color=red>4 * 2</font>\r\n&lt;- <strong><font color=magenta>xs</font></strong>\r\n</pre>\r\n<p>\r\nHere, the error message is chosen as the starting point, rather\r\nthan any of the output.  The first trail is therefore\r\n<kbd>last' []</kbd>, because its evaluation caused the error message.\r\nThe parent of <kbd>last' []</kbd> is\r\n<kbd>last' [_]</kbd>.  The parent of <kbd>last' [_]</kbd>\r\nis <kbd>last' [_,_])</kbd>, etc. The parent of the\r\nsubexpression <kbd>8</kbd> is <kbd>4*2</kbd> whose parent is\r\n<kbd>xs</kbd>.\r\n<p>\r\n\r\n<li><strong>Hat-explore</strong><br>\r\nHat-explore allows you to step through a computation. Like a conventional debugger hat-explore highlights your current position in the computation in the program source and shows a stack backtrace of function calls. In contrast to conventional debuggers you are free of the actual evaluation order when stepping through the computation. From any function call you can go down to any further function called by it, to a function call in the same function definition, or upwards to the caller of the current function call. \r\n<p>\r\nBecause arguments and the result are shown for each function call, it is easier to determine which function is incorrect. You can also mark reductions as correct/incorrect which enables the tool to pinpoint the bug to a smaller and smaller slice of the program.\r\n\r\n<pre>\r\n<strong>==== Hat-Explore 2.04 ==== Press h for help. ===================</strong>\r\n 1. <font color=blue>main = {IO}</font>\r\n 2. <font color=blue>last' [8,_,_] = _|_</font>\r\n 3. <font color=blue>last' [_,_] = _|_</font>\r\n 4. <font color=blue>last' [_] = _|_</font>\r\n 5. <font color=blue>last' [] = _|_</font>\r\n<strong>---- Last.hs ---- lines 1 to 7 ---------------------------------</strong>\r\n\r\nmain = let xs :: [Int]\r\n           xs = [4*2,5 `div` 0,5+6]\r\n       in  print (head xs,last' xs)\r\n\r\nlast' (x:xs) = <font color=blue>last' xs</font>\r\nlast' [x] = x\r\n</pre>\r\n\r\n<li><strong>Hat-detect</strong> (inspired by <a\r\nhref=\"http://www.ida.liu.se/~henni/\">Freja</a>) <br>\r\nHat-detect is an interactive tool that enables the semi-automatic\r\nlocation of an error in a program by answering a sequence of yes/no\r\nquestions.  Each question asked by hat-detect concerns the reduction\r\nof a redex - that is, a function application - to a value.  You have to\r\nanswer <em>yes</em>, if the reduction is correct with respect to your\r\nintentions, and <em>no</em> otherwise.  After a number of questions\r\nhat-detect states which reduction is the cause of the observed faulty\r\nbehaviour - that is, which function definition is incorrect.\r\n\r\n<p>\r\nExample session (y/n answers are given by the user):\r\n<pre>\r\n$ hat-detect Example\r\n\r\n                hat-detect 2.0x    (:h for help, :q to quit)\r\n\r\n<font color=blue>1</font>  main = IO (print [3,3,3])   ? n\r\n<font color=blue>2</font>  sort [3,2,1] = [3,3,3]   ? n\r\n<font color=blue>3</font>  insert 1 [] = [1]     ? y\r\n<font color=blue>4</font>  insert 2 [1] = [2,2]     ? n\r\n<font color=blue>5</font>  insert 2 [] = [2]     ? y\r\n\r\nError located!\r\nBug found in reduction:   insert 2 [1] = [2,2]\r\n</pre>\r\n<p>\r\n\r\n\r\n<li><strong>Hat-stack</strong><br>\r\n\r\nFor aborted computations, that is computations that terminated\r\nwith an error message or were interrupted, hat-stack shows in which\r\nfunction call the computation was aborted.  It does so by showing a\r\n<em>virtual</em> stack of function calls (redexes).  Thus, every function\r\ncall shown on the stack caused the function call above it. The evaluation\r\nof the top stack element caused the error (or during its evaluation\r\nthe computation was interrupted).  The stack shown is <em>virtual</em>,\r\nbecause it does not correspond to the actual runtime stack.  The actual\r\nruntime stack enables lazy evaluation whereas the <em>virtual</em>\r\nstack corresponds to a stack that would be used for eager (strict)\r\nevaluation.\r\n\r\n<p>\r\nUsing the same example program as above, hat-stack shows\r\n<pre>\r\n$ hat-stack Example\r\nProgram terminated with error:\r\n        No match in pattern.\r\nVirtual stack trace:\r\n(Last.hs:6)     last' []\r\n(Last.hs:6)     last' [_]\r\n(Last.hs:6)     last' [_,_]\r\n(Last.hs:4)     last' [8,_,_]\r\n(unknown)       main\r\n$\r\n</pre>\r\n<p>\r\n\r\n</ul>\r\n\r\n### Language Coverage\r\n\r\nOriginally Hat was built to trace programs written in Haskell 98, using the Haskell 98 standard libraries. Hat now also supports most of Haskell 2010 (only part of the foreign function interface) plus some language extensions, such as multi-parameter type classes and functional dependencies.\r\n\r\n### Documentation\r\n\r\nIn the distribution there is documentation in the \"docs\" folder, but much of it is outdated.\r\nThere are a few small programs for exploring tracing in the \"examples\" folder.\r\n\r\n<ul>\r\n<li><a href=\"www.cs.york.ac.uk/fp/ART/\">Outdated but still useful documentation at York</a>\r\n</ul>\r\n\r\n### Development \r\n\r\nThe following work is ongoing or planned:\r\n\r\n<ul>\r\n<li>The source-to-source transformation of hat-trans is being rewritten to use the haskell-src-exts parser. Thus small bugs of the current parser will disappear and in the future it will be easier to cover more Haskell language extensions.\r\n<li>When a traced program uses any libraries besides the standard Haskell 98 / 2010 ones, these libraries currently have to be manually transformed (in trusted mode). A new tool will be built to easily wrap any existing libraries such that they can be used by a traced program (without tracing the computations inside the libraries).\r\n<li>All viewing tools use a textual interface; however, many tools use some Unix-specific features and thus run on Unix / Linux / OS X, but not on Windows. The tools will be modified to use only libraries for their user interfaces that work also on Windows.\r\n</ul>\r\n\r\n### Installation\r\n\r\nDon't download from Git but use the package manager cabal.\r\nEnsure that you have the Glasgow Haskell compiler [ghc](http://www.haskell.org/ghc) and the package manager [cabal](http://www.haskell.org/cabal). You can get both easily by installing the [Haskell Platform](http://www.haskell.org/platform). Then execute\r\n\r\n<pre>\r\n$ cabal install hat -v\r\n</pre>\r\n\r\nFlag -v allows you to see what is going on. Building takes a long time \r\n(one module has 25.000 lines of code). Don't worry about numerous warning messages.\r\n\r\nUse:\r\n<pre>\r\n$ hat-make MyProgram.hs\r\n</pre>\r\ntransforms and compiles all modules of your program and produces the tracing\r\nversion Hat/MyProgram.\r\n\r\nRun your program \r\n<pre>\r\nHat/MyProgram\r\n</pre>\r\nwhich will produce trace files MyProgram.hat*\r\n\r\nUse the viewing tools to explore the trace:\r\n<pre>\r\n$ hat-trail / hat-observe / hat-explore /...   MyProgram\r\n</pre>\r\n"}